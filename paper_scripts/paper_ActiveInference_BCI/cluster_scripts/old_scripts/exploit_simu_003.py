import numpy as np
import statistics as stat
import scipy.stats as scistats
import math,sys,os,inspect
import shutil

import pickle 
import matplotlib.pyplot as plt

import actynf

from tools import dist_kl_dir,js_dir # A tool to qualify subject learning

#!/usr/bin/python
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0, parentdir) 

# Generate a succession of trial results for a model in a list
# Made to work as a command and simulate a single model index
# To integrate in a cluster like environment

def generate_a_parameter_list(A_priors,a_priors,a_weights) :
    # Undordered dictionnaries are soooo not cool :(
    simulation_index_list = []    
    for kA in range(len(A_priors)):
        for ka in range(len(a_priors)):
            for wa in range(len(a_weights)) :
                this_sim = {
                    "filename" : "_" + str(A_priors[kA]) + "_" + str(a_priors[ka])+"_"+str(a_weights[wa])+"_.simu",
                    "A_std" : A_priors[kA],
                    "a_std" : a_priors[ka],
                    "a_wgt" : a_weights[wa]
                }

                simulation_index_list.append(this_sim)
    return simulation_index_list

def extract_training_data(savepath):
    # EXTRACT TRAINING CURVES    
    with open(savepath, 'rb') as handle:
        saved_data = pickle.load(handle)
    stms = saved_data["stms"]
    weights = saved_data["matrices"]

    Nsubj = len(stms)
    Ntrials = len(weights[0])-1 # One off because we save the initial weights (= trial 0)
    return stms,weights,Nsubj,Ntrials

def initialize_3darray(Ns,Ny,Nz):
    L = []
    for x in range(Ns):
        L.append([])
        for y in range(Ny):
            L[-1].append([])
            for z in range(Nz):
                L[-1][-1].append([])
    return L

def save_object_to(obj,savepath,override=True):
    if not os.path.exists(os.path.dirname(savepath)):
        os.makedirs(os.path.dirname(savepath))

    exists = os.path.isfile(savepath)
    if (not(exists)) or (override):
        print("Saving to " + savepath)
            
        with open(savepath, 'wb') as handle:
            pickle.dump(obj, handle, protocol=pickle.HIGHEST_PROTOCOL)
        print("Saved to :   " + savepath)

def save_performances():
    """
    Change the format of the save
    """
    save_folder_name = os.path.join(os.path.abspath(os.sep),"mnt","data","Come_A","results","new_sims","003")
    all_files = [os.path.join(save_folder_name, f) for f in os.listdir(save_folder_name) if os.path.isfile(os.path.join(save_folder_name, f))]
    
    K = 20
    Kw = 10

    simulation_min_value = 0.001
    simulation_max_value = 3.0

    key_array = initialize_3darray(K,K,Kw)
    results_states = initialize_3darray(K,K,Kw)
    extract_this_models_a = initialize_3darray(K,K,Kw)
    extract_this_models_b = initialize_3darray(K,K,Kw)

    Nfiles = len(all_files)
    for k,file in enumerate(all_files):

        filename = os.path.basename(file)
        print(str(k) + "  / " + str(Nfiles) + "  -- "  +filename)
        
        param_val = filename.split("_")
        
        value_1 = float(param_val[-4])  # True feedback noise
        value_2 = float(param_val[-3])  # Belief feedback noise
        value_3 = float(param_val[-2])  # Belief feedback initial weights
        
        kA = (int(K*(value_1-simulation_min_value)/simulation_max_value))
        ka = (int(K*(value_2-simulation_min_value)/simulation_max_value))
        kW = (int(value_3)-1)

        parameter_values = np.array([value_1,value_2,value_3])
        key_array[kA][ka][kW] = parameter_values
                
        _stm,_weight,_Nsubj,_Ntrials = extract_training_data(file)

        state_perfs = [[_stm[subj][idx][0].x[0] for idx in range(1,_Ntrials+1)] for subj in range(_Nsubj)]
        state_perfs_array = np.array(state_perfs)
        results_states[kA][ka][kW] = state_perfs_array

        true_A = _weight[0][0][0]["a"][0]
        # a_dists =  [[dist_kl_dir(_weight[subj][trial][1]["a"][0],true_A) for trial in range(1,_Ntrials+1)] for subj in range(_Nsubj)]
        a_dists =  [[js_dir(_weight[subj][trial][1]["a"][0],true_A) for trial in range(1,_Ntrials+1)] for subj in range(_Nsubj)]
        a_dists_array = np.array(a_dists)
        extract_this_models_a[kA][ka][kW] = a_dists_array
        

        true_B = _weight[0][0][0]["b"][0]
        # b_dists = [[dist_kl_dir(_weight[subj][trial][1]["b"][0],true_B) for trial in range(1,_Ntrials+1)] for subj in range(_Nsubj)]
        b_dists = [[js_dir(_weight[subj][trial][1]["b"][0],true_B) for trial in range(1,_Ntrials+1)] for subj in range(_Nsubj)]
        b_dists_array = np.array(b_dists)
        extract_this_models_b[kA][ka][kW] = b_dists_array


    save_folder_name_arrayed = os.path.join(save_folder_name,"compressed")
    
    key_array = np.array(key_array) # array of size K x K x Kw x 3
    save_object_to(key_array,os.path.join(save_folder_name_arrayed,"KEYS"))
    subject_performances = {
        "s":np.array(results_states),
        "a":np.array(extract_this_models_a),
        "b":np.array(extract_this_models_b)
    }
    save_object_to(subject_performances,os.path.join(save_folder_name_arrayed,"PERFS_js"))
    

if __name__ == "__main__":
    save_performances() # Transform the names of the file into array coordinates !        
    