import numpy as np
import statistics as stat
import scipy.stats as scistats
import math,sys,os,inspect
import pickle 
import matplotlib.pyplot as plt

import actynf


#!/usr/bin/python
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0, parentdir) 

# Generate a succession of trial results for a model in a list
# Made to work as a command and simulate a single model index
# To integrate in a cluster like environment

def generate_a_parameter_list(A_priors,a_priors,a_weights) :
    # Undordered dictionnaries are soooo not cool :(
    simulation_index_list = []    
    for kA in range(len(A_priors)):
        for ka in range(len(a_priors)):
            for wa in range(len(a_weights)) :
                this_sim = {
                    "filename" : "_" + str(A_priors[kA]) + "_" + str(a_priors[ka])+"_"+str(a_weights[wa])+"_.simu",
                    "A_std" : A_priors[kA],
                    "a_std" : a_priors[ka],
                    "a_wgt" : a_weights[wa]
                }

                simulation_index_list.append(this_sim)
    return simulation_index_list
    
# Useful function, might add it to the network class !
def simulate_and_save(my_net,savepath,Nsubj,Ntrials,override=False):
    if not os.path.exists(os.path.dirname(savepath)):
        os.makedirs(os.path.dirname(savepath))

    exists = os.path.isfile(savepath)
    if (not(exists)) or (override):
        stm_subjs = []
        weight_subjs = []
        print("Saving to " + savepath)
        for sub in range(Nsubj):
            subj_net = my_net.copy_network(sub)

            STMs,weights = subj_net.run_N_trials(Ntrials,return_STMs=True,return_weights=True)
            stm_subjs.append(STMs)
            weight_subjs.append(weights)

        save_this = {
            "stms": stm_subjs,
            "matrices" : weight_subjs
        }
            
        with open(savepath, 'wb') as handle:
            pickle.dump(save_this, handle, protocol=pickle.HIGHEST_PROTOCOL)
        print("Saved to :   " + savepath)

def extract_training_data(savepath):
    # EXTRACT TRAINING CURVES    
    with open(savepath, 'rb') as handle:
        saved_data = pickle.load(handle)
    stms = saved_data["stms"]
    weights = saved_data["matrices"]

    Nsubj = len(stms)
    Ntrials = len(weights[0])-1 # One off because we save the initial weights (= trial 0)
    return stms,weights,Nsubj,Ntrials

def initialize_list_of_list(Ns,Ny):
    z = []
    for x in range(Ns):
        z.append([])
        for y in range(Ny):
            z[-1].append(None)
    return z

if __name__ == "__main__":
    trials_last_N = 15

    # save_folder_name = os.path.join(os.path.abspath(os.sep),"mnt","data","Come_A","results","new_sims","001")

    K = 20
    true_fb_std_array = list(np.linspace(0.001,1.2,K))
    belief_fb_std_array = list(np.linspace(0.001,1.2,K))

    lis = initialize_list_of_list(K,K)
    extract_this = initialize_list_of_list(K,K)

    save_folder_name = os.path.join(os.path.abspath(os.sep),"mnt","data","Come_A","results","new_sims","004")
    all_files = [os.path.join(save_folder_name, f) for f in os.listdir(save_folder_name) if os.path.isfile(os.path.join(save_folder_name, f))]
    
    xs = []
    ys = []
    for file in all_files:
        param_val = file.split("_")
        print(param_val)

        value_1 = float(param_val[-3])
        value_2 = float(param_val[-2])
        
        kx = (int(K*(value_1-0.001)/1.2))
        ky = (int(K*(value_2-0.001)/1.2))
        lis[kx][ky] = [value_1,value_2]

        _stm,_weight,_Nsubj,_Ntrials = extract_training_data(file)
        
        state_perfs = [[_stm[subj][idx][0].x[0] for idx in range(1,_Ntrials+1)] for subj in range(_Nsubj)]
        state_perfs_array = np.array(state_perfs)
        extract_this[kx][ky] = np.mean(state_perfs_array[-trials_last_N:,:])

    print(lis)
    print()
    print(extract_this)
    