#!/usr/bin/python
from json import load
import sys,inspect,os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.animation as animation
plt.rcParams["figure.figsize"] = [7.50, 3.50]
plt.rcParams["figure.autolayout"] = True
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.collections import PolyCollection


# currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
# parentdir = os.path.dirname(currentdir)
# sys.path.insert(0, parentdir) 

from pyai.base.file_toolbox import save_flexible,load_flexible
from pyai.layer.layer_learn import MemoryDecayType
from pyai.model.active_model import ActiveModel
from pyai.neurofeedback_run import evaluate_model_mean

from pyai.models_neurofeedback.climb_stairs import nf_model,evaluate_container

from pyai.base.miscellaneous_toolbox import smooth_1D_array

import time as t

# We grab a "performance_ouptut.pyai" file and extract the data :D
def load_perf(filepath):
    return (load_flexible(filepath))

def generate_grids(model_list,pick_t,parameter_index,size = (12,12),smooth_it = 0):
    Xgrid = np.zeros(size)
    Ygrid = np.zeros(size)
    Zgrid = np.zeros(size)
    for model in model_list :
        model_object = model[0]
        results_list = model[1]
        options = model_object.input_parameters
        index = tuple(model_object.index)
        #print(index)
        #print(options[1],options[4])
        Xgrid[index] = options[1]
        Ygrid[index] = options[4]
        Zgrid[index] = results_list[parameter_index][pick_t]
        if(smooth_it > 0):
            sum = 0
            cnt = 0
            for k in range(pick_t-smooth_it,pick_t + smooth_it + 1):
                try :
                    sum += results_list[parameter_index][k]
                    cnt += 1
                except :
                    sum += 0
                    cnt += 0
            Zgrid[index] = sum/cnt
    return Xgrid,Ygrid,Zgrid

def show_animation(file,im_interested_in,fps = 40):
    list_of_models = file
    n = len(list_of_models)
    max_x = 0
    max_y = 0
    for k in range(n):
        index = (file[k]['model'].index)
        if (index[0]>max_x):
            max_x = index[0]
        if(index[1]>max_y): 
            max_y = index[1]

    print(max_x,max_y)
    max_t = list_of_models[0]['mean']['perception_error'].shape[0]
    print(max_t)



    arrs = np.zeros((3,max_x+1,max_y+1,max_t))
    for k in range(n):
        model_sumup_file = file[k]
        index = model_sumup_file['model'].index
        a_error = model_sumup_file['model'].input_parameters[1]
        b_error = model_sumup_file['model'].input_parameters[4]
        interesting_quantity = model_sumup_file['mean'][im_interested_in]
        if (a_error=='perfect'):
            a_error = 5
        if (b_error=='perfect'):
            b_error = 5
        arrs[0,index[0],index[1],:] = a_error
        arrs[1,index[0],index[1],:] = b_error
        arrs[2,index[0],index[1],:] = interesting_quantity[:,0]
    
    

    def change_plot(frame_number, full_array, plot):
        plot[0].remove()
        #plot[0] = ax.plot_surface(x, y, zarray[:, :, frame_number], cmap="afmhot_r")
        plot[0] = ax.plot_surface(full_array[0,:,:,frame_number], full_array[1,:,:,frame_number], full_array[2,:,:,frame_number], cmap=cm.coolwarm,linewidth=0, antialiased=False)
    
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.set_xlabel('a variance')
    ax.set_ylabel('b variance')


    param_plot = im_interested_in
    if (param_plot=='a_error'):
        ax.set_zlabel('PERCEPTION MODEL error')
        ax.set_title('PERCEPTION MODEL error - KL(a,A)')
    elif  (param_plot==4):
        ax.set_zlabel('ACTION MODEL error')
        ax.set_title('ACTION MODEL error - KL(b,B)')
    elif  (param_plot==5):
        ax.set_title('PERCEPTION MODEL entropy - E(a)')
        ax.set_zlabel('PERCEPTION MODEL entropy')
    elif  (param_plot==6):
        ax.set_zlabel('ACTION MODEL entropy')
        ax.set_title('ACTION MODEL entropy - E(b)')
    elif  (param_plot==7):
        ax.set_zlabel('INITIAL STATE MODEL entropy')
        ax.set_title('INITIAL STATE MODEL entropy - E(d)')
    elif  (param_plot==8):
        ax.set_zlabel('state error')
        ax.set_title('TRUE STATE error - ||optimal,true||_s')
    elif  (param_plot==9):
        ax.set_zlabel('actions taken error')
        ax.set_title('TRUE ACTIONS TAKEN error - ||optimal,true||_u')
    elif  (param_plot==10):
        ax.set_zlabel('observations error')
        ax.set_title('TRUE OBSERVATIONS error - ||optimal,true||_o')
    elif  (param_plot==11):
        ax.set_zlabel('perception error')
        ax.set_title('TRUE PERCEPTION error - KL(s_estimated,s_true)')
    else : 
        ax.set_zlabel(param_plot)
    
    plot = [ax.plot_surface(arrs[0,:,:,0], arrs[1,:,:,0], arrs[2,:,:,0], color='0.75', rstride=1, cstride=1)]
    ax.set_zlim(0, 1.1)
    ani = animation.FuncAnimation(fig, change_plot, max_t, fargs=(arrs, plot), interval=1000 / fps)
    plt.show()

    #show_animation(file,im_interested_in)
def figure_at_t(file,t,im_interested_in):
    list_of_models = file
    n = len(list_of_models)
    max_x = 0
    max_y = 0
    for k in range(n):
        index = (file[k]['model'].index)
        if (index[0]>max_x):
            max_x = index[0]
        if(index[1]>max_y): 
            max_y = index[1]

    max_t = list_of_models[0]['mean']['perception_error'].shape[0]
    val_for = 4.25
    arrs = np.zeros((3,max_x+1,max_y+1,max_t))
    for k in range(n):
        model_sumup_file = file[k]
        index = model_sumup_file['model'].index
        a_error = model_sumup_file['model'].input_parameters[1]
        b_error = model_sumup_file['model'].input_parameters[4]
        interesting_quantity = model_sumup_file['mean'][im_interested_in]
        if (a_error=='perfect'):
            a_error = val_for
        if (b_error=='perfect'):
            b_error = val_for
        arrs[0,index[0],index[1],:] = a_error
        arrs[1,index[0],index[1],:] = b_error
        arrs[2,index[0],index[1],:] = interesting_quantity[:,0]

    perfect_line = np.argmax(arrs[0,:,0,0]) # This for a model = perfect
    perfect_column = np.argmax(arrs[1,0,:,0]) # This for b model = perfect

    performances_for_perfect_x = arrs[:,perfect_line,:,:]
    performances_for_perfect_y = arrs[:,:,perfect_column,:]

    remove_perfect_line = np.delete(arrs,perfect_line,axis=1)
    remove_perfect_line = np.delete(remove_perfect_line,perfect_column,axis = 2)
    #print(remove_perfect_line.shape)

    # x = np.linspace(-3, 3, 256)
    # y = np.linspace(-3, 3, 256)
    # X, Y = np.meshgrid(x, y)
    # Z = np.exp(-(X ** 2 + Y ** 2))
    # u = np.exp(-(x ** 2))

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.set_zlim3d(0, 1)
    
    #ax.fill_between(performances_for_perfect_x[1,:,t], performances_for_perfect_x[2,:,t])
    #ax.fill_between(performances_for_perfect_y[0,:,t], performances_for_perfect_x[2,:,t])
    
    verts_perfect_x = [list(zip(performances_for_perfect_x[1,:,t],performances_for_perfect_x[2,:,t]))]
    verts_perfect_x[0].insert(0,(1.0,0.0))
    poly_x = PolyCollection(verts_perfect_x,facecolors='green')
    poly_x.set_alpha(0.6)
    ax.add_collection3d(poly_x,zs=val_for,zdir='x')
    
    ax.plot(performances_for_perfect_x[1,:,t], performances_for_perfect_x[2,:,t], zs=val_for, zdir='x', lw = 2, color = 'green',label="Perfect perception model (precision a --> +oo)")
    ax.plot(performances_for_perfect_y[0,:,t], performances_for_perfect_y[2,:,t], zs=val_for, zdir='y', lw = 2., color = 'purple',label="Perfect action model (precision b --> +oo)")
    
    verts_perfect_y = [list(zip(performances_for_perfect_y[0,:,t],performances_for_perfect_y[2,:,t]))]
    verts_perfect_y[0].insert(0,(1.0,0.0))
    poly_y = PolyCollection(verts_perfect_y,facecolors='purple')
    poly_y.set_alpha(0.6)
    ax.add_collection3d(poly_y,zs=val_for,zdir='y')
    
    ax.plot_surface(remove_perfect_line[0,:,:,t], remove_perfect_line[1,:,:,t], remove_perfect_line[2,:,:,t], cmap=cm.coolwarm,linewidth=0, antialiased=False,alpha=0.9)
    ax.set_xlabel("Precision of a prior")
    ax.set_ylabel("Precision of b prior")
    ax.set_zlabel(im_interested_in)
    ax.set_title("Evolution of " + im_interested_in + " for varying subject perception / action priors")
    ax.legend()
    ax.set_xlim(0.9,5)
    ax.set_ylim(0.9,5)
    return fig,ax   

if __name__=="__main__":
    savepath = os.path.join("C:",os.sep,"Users","annic","Desktop","Phd","cluster_results")
    filename = "simulation_output_005.pyai"

    im_interested_in = "b_error"
    t0 = t.time()
    file = load_flexible(os.path.join(savepath,filename))
    t1 = t.time()
    print("Loading file " + filename + " in " + str(np.round(t1 - t0,2)) + " seconds .")
    
    # 4 : 8 x 9, a std x a mean (1,2),learn_a
    # 5 : 8 x 9, A mean x A std (4,3), NOT learn a --> a is perfect, but A is different
    # 6 : 8 x 8, a std x A std (1,3), learn a

    T = 200
    smoother = 3
    N_models = len(file)
    index = 5
    arr = np.zeros((8,9 ,3,T))

    i = 8
    j = 9
    modelboard = [[None]*j for k in range(i)]
    print(modelboard)
    for model in file:
        coordx = model['model'].index[1]
        coordy = model['model'].index[3]
        print(model['model'].index)
        modelboard[coordx][coordy] = model
    
    fig,axes = plt.subplots(2,8,sharey='row')

    for std_value in range(i):
        print(modelboard[std_value][int(j/2.0)]['model'].input_parameters)
        dict_object = modelboard[std_value][int(j/2.0)] # No meanskew
        A_matrix = dict_object['model'].A
        axes[0,std_value].imshow(A_matrix[0])
        # for major ticks
        axes[0,std_value].set_xticks([])
        axes[0,std_value].set_yticks([])
        # for minor ticks
        axes[0,std_value].set_xticks([], minor=True)
        axes[0,std_value].set_yticks([], minor=True)
        
        avg_state_error = dict_object['mean']['state_error']
        avg_state_error = smooth_1D_array(avg_state_error[:T],smoother)
        std_state_error = smooth_1D_array(np.sqrt(dict_object['variance']['state_error'][:T]),smoother)

        avg_obs_error = dict_object['mean']['observation_error'][:T]
        #axes[1,std_value].plot(np.linspace(0,T,T),avg_obs_error)

        avg_b_error = dict_object['mean']['b_error'][:T,0]
        std_b_error = np.sqrt(dict_object['variance']['b_error'])[:T,0]
        print(avg_b_error.shape,std_b_error.shape)

        # avg_a_error = dict_object['mean']['a_error']
        # axes[1,std_value].plot(np.linspace(0,T,T),avg_a_error)

        avg_p_error = dict_object['mean']['perception_error']
        avg_p_error = smooth_1D_array(avg_p_error[:T],smoother)
        std_p_error = smooth_1D_array(np.sqrt(dict_object['variance']['perception_error'][:T]),smoother)
        # avg_u_error = dict_object['mean']['behaviour_error']
        # axes[1,std_value].plot(np.linspace(0,T,T),avg_u_error)
        
        transparency = 0.3
        axes[1,std_value].fill_between(np.linspace(0,T,T),avg_state_error-std_state_error,avg_state_error+std_state_error,color=np.array([0,0,1,transparency]))
        axes[1,std_value].fill_between(np.linspace(0,T,T),avg_b_error-std_b_error,avg_b_error+std_b_error,color=np.array([1,0,0,transparency]))
        axes[1,std_value].fill_between(np.linspace(0,T,T),avg_p_error-std_p_error,avg_p_error+std_p_error,color=np.array([0,1,0,transparency]))

        if (std_value==0):
            axes[1,std_value].plot(np.linspace(0,T,T),avg_state_error,color='blue',label="State error (current state vs optimal state)")
            axes[1,std_value].plot(np.linspace(0,T,T),avg_b_error,color='red',label="Action model error (model learnt vs true model)")
            axes[1,std_value].plot(np.linspace(0,T,T),avg_p_error,color='green',label="Perception error (true state vs belief about state)")
        else :
            axes[1,std_value].plot(np.linspace(0,T,T),avg_state_error,color='blue')
            axes[1,std_value].plot(np.linspace(0,T,T),avg_b_error,color='red')
            axes[1,std_value].plot(np.linspace(0,T,T),avg_p_error,color='green')
        axes[1,std_value].set_ylim(0.0,1.0)
        axes[1,std_value].set_xlabel("Trials")
        axes[1,std_value].grid()
    axes[0,0].set_ylabel("True feedback map")    
    axes[1,0].set_ylabel("Error")
    fig.legend(loc='upper center')
    plt.show()